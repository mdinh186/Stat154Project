---
title: "ProjectEDA"
author: "Emily"
date: "12/4/2017"
output:
  html_document: default
  pdf_document: default
---

#Introduction

The data used for this project came from 

- Summary of the project and data, as well as any relevant context, background, or framing issues.

The "big question" we are looking to address in this report is the classification of factors that predict whether or not a person's salary in 1994 is greater or less than 50K. The purpose of this project is to construct and analyze various models generated by classification trees.

For this report, we examine and clean the various features of our original data, and then select the features which appear to have the most influence on income prediction through       . After performing feature selection, we model three different classification trees and analyze the results. We find that our most successful tree is          .

```{r}
#Libraries called:
library(data.table)
library(ggplot2)
library(ggforce)
library(GGally)
library(car)
library(nortest)
library(MASS)
library(forecast)
library(psych)
library(MissMech)
library(readr)
library(dplyr)
library(party)
library(rpart)
library(rpart.plot)
library(ROCR)
library(class)
library(Hmisc)
library(missForest)
set.seed(100) #not sure if this is necessary but just in case

```


#Exploratory Data Analysis (EDA)

#####Original Dataset
```{r}
#rm(list = ls())
dir = "/Users/MyDinh/Downloads/Stat154/Projects"
setwd(dir)
df  = read.table("data/adult.data", sep = ",",colClasses=c("numeric", "character", "numeric", "factor","numeric", "factor", "character", "factor", "factor", "factor", rep("numeric", 3),"character","factor"))

names(df) = c("age", "workclass", "fnlwgt", "education", "education-num", 
              "marital-status", "occupation", "relationship", "race", "sex",
              "capital-gain", "capital-loss", "hours-per-week",
              "native_country","income")

df <- as.data.frame(df)

summary(df)

str(df)
```

At first glance, the original dataset was immense; creating an interpretable classification tree from this would need thoughtful data preparation. As such, we focused heavily on properly analyzing the data and examining each variable.


#### Analysis of House Income: 

```{r}
ggplot(df,aes(x = "Income")) + geom_bar(alpha= .8, fill = "lightblue") + labs(x = "Income")
```
There appears to be a problem with imbalanced classes. We need to make necessary adjustments to adjust the probability threshold for imbalanced class. 

Let's see if the income has any relationship with the predictors: 

```{r, warning=F}
df_cont = df[, c(1,3, 5, 11:13,15)]
df_cat = df[, -c(1,3, 5, 11:13)]
par(mfrow=c(1,1))
names = colnames(df_cont)

for (i in 1:(ncol(df_cont)-1)) {
  print(paste("Summary table for income over", names[i]))
  df_plot = data.frame(x= df_cont[[i]], income = df_cont$income)
 
  print(tapply(df_plot$x, df_plot$income, summary))
  g1 = ggplot(df_plot, aes(x = x, fill = income)) + 
    geom_histogram() + 
    facet_grid(~income) + theme_bw() +
    labs(x= names[i])
  print(g1)
}
```

We observed: 

* Capital loss: people with income over 50K tend to have higher capital loss overall, but with smaller maximum capital loss
* Capital gain: people with income over 50K tend to have higher capital gains, with some extreme outliers with values over 100k 
* Age: the age distribution of people whose income less than 50K tends to skewed to the left, indicating that they are of a younger age. Meanwhile, the age distribution of people with income higher than 50K is roughly normal, with higher mean and median. 
* Education number: people with higher income tend to have higher education-numbers
* fnlwgt: both income groups roughly share the same distribution for the final weight

### Missing values: 

Let check how many missing values exist for each variable:
```{r}
sapply(df, function(x) sum(is.na(x)))

### it seems "?" represents as missing values
### Lets do a recount again: 
### convert factor columns into charactor: 

df_fac = df[,c(2, 7, 14)]
sapply(df_fac, function(x) table(x)[1])/nrow(df) *100 ### getting percentage

NA_factor <- function(data){
  #Dealing with NAs
  data[data == " ?"] <- NA #Change all '?' values to NA
  NA_Columns <- colSums(is.na(data)) #per column
  NA_percent <- colMeans(is.na(data)*100) #percents
  
  #Convert back to factors
    data$"workclass" <- as.factor(data$"workclass")
    data$"occupation" <- as.factor(data$"occupation")
    data$"native_country" <- as.factor(data$"native_country")
    data
}

df <- NA_factor(df)
length(which(complete.cases(df)==FALSE)) #Number of observations with NA values
```
There is a total of 4262 missing values, for 2399 observations. Missing values are seen in the original dataset as '?' symbols. All the missing values belonged to three columns: occupation, nativecountry, and workclass, and multiple missing values were frequent for the same observation. As thus, it is very likely that the missing values are not at random (MNAR). 

Let's see if there is any pattern in those missing values: 

```{r}
col_missing = names(df_fac)

plot_Missing = function(data){
  temp_df = cbind(data)
  temp_df[temp_df == " ?"] = NA
  temp_df = as.data.frame(ifelse(is.na(temp_df), 0,1))
  data_temp = expand.grid(list(x = 1:nrow(temp_df), y = colnames(temp_df)))
  data_temp$m = as.vector(as.matrix(temp_df))
  data_temp = data.frame(x = unlist(data_temp$x), y = unlist(data_temp$y),  m= unlist(data_temp$m))
  ggplot(data_temp) + geom_tile(aes(x = x, y = y, fill = factor(m))) +
    scale_fill_manual(values= c("white", "black"), name = "Missing\n(0 = Yes, 1 = No)") + 
    theme_light() + 
    ylab("") +
    xlab("") 
  }

plot_Missing(df)
```

Based on this graph, the missing values for columns workclass and education seem to be corresponded to each other, while native country may be more random. 

We will try to impute the missing values and remove it from the data and see what version works better.

####Imputing NA:
We decided to try imputing our NA values, using the missForest function, which should be sufficient for MNAR instances. 
```{r}
NA_imputes <- function(data){
   #Imputation of factorized data
      imputationResults <- missForest(xmis = data, maxiter = 2, variablewise = TRUE)
      dataMissForestImputed <- imputationResults$ximp #this is the adult data set with all the imputations
      }

#function for imputing missing values
df_impute <- NA_imputes(df)
```

#####Plots of the data before and after imputation
```{r}
plot(df$occupation)
plot(df_impute$occupation, col = rgb(1,0,0,1/4), add=T)

plot(df$workclass, col = rgb(0, 1, 1, 1/8))
plot(df_impute$workclass, col = rgb(1,0,0,1/10), add=T)

plot(df$native_country, col = rgb(0, 1, 1, 1/8))
plot(df_impute$native_country, col = rgb(1,0,0,1/16), add=T)
```

####Removing NAs:
```{r}
df_remove <- na.omit(df)
```

#####Plots of the data before and after imputation
```{r}
plot(df$occupation)
plot(df_remove$occupation, col = rgb(1,0,0,1/4), add=T)

plot(df$workclass, col = rgb(0, 1, 1, 1/8))
plot(df_remove$workclass, col = rgb(1,0,0,1/10), add=T)

plot(df$native_country, col = rgb(0, 1, 1, 1/8))
plot(df_remove$native_country, col = rgb(1,0,0,1/16), add=T)
```

As we have now addressed our missing values, we can move onto examining our various features of the data.


#### Feature engineering: 

1. We will combine some levels of education so that we will have less levels and more insight. 

The split up based on the census income report in 1994: 
https://www.census.gov/prod/1/pop/p60-189.pdf

We will have 10 following levels; 

* Less than high school
* High school with no degree
* High school diploma or equivalent
* Some college, no degree
* Associate’s degree
* Bachelor’s degree
* Master’s degree
* Doctoral degree and professional degree

```{r}
combine_education = function(dat){
  dat <- data.table(dat)
  dat$education = as.character(dat$education)
  level1 = c(" Preschool"," 1st-4th", " 5th-6th", " 7th-8th")
  dat[,education := ifelse(education %in% level1, "Less than highschool",education)] 
  level2 = c(" 9th", " 10th", " 11th", " 12th")
  dat[,education := ifelse(education %in% level2, "HS with no degree",education)] 
  dat[,education := ifelse(education == " HS-grad", "HS",education)] 
  level3 = c(" Assoc-acdm"," Assoc-voc")
  dat[,education := ifelse(education %in% level3, "Associate",education)] 
  level4 = c(" Prof-school", " Doctorate")
  dat[,education := ifelse(education %in% level4, "Doctorate or Professional",education)] 
  return (dat)
}

df_feat =  combine_education(df)
edu_income = table(df_feat$education, df$income)
edu_income = data.table(Degree = rownames(edu_income), Less_50k = edu_income[,1], More_50k = edu_income[,2])
edu_income = melt(edu_income, id.vars = "Degree", measure.vars = 2:3)

ggplot(edu_income, aes(factor(Degree), value, fill = variable)) + 
  geom_bar(stat="identity", position = "dodge") + 
  scale_fill_brewer(palette = "Set1") +
  labs(x = "Degree",y = "Income")
```
From this, we can easily see that for degrees from less-than high school to Bachelor, people are more likely to have lower incomes than those with more advanced degree. 

Let's change the degree with actual income, and modify the above function: 

```{r}
education_median = function(dat){
  dat <- data.table(dat)
  degree = unique(dat$education)
  degree_median_income = data.frame(education = degree, 
                                    Edu_Mean_income = c(52370,30071,17543,61045,35879,40258,14275,78079))
  dat = merge(dat, degree_median_income, by = "education")
  return (dat)
}
df_feat = education_median(df_feat)
```

Finally, as education and education-num represented essentially the same data, we decided to remove one of them from our dataset. Education-num could also be slightly misleading, since the "10th grade" is labeled as having "5 years" of education, and so forth. As such, we decided it would be better to keep education, which is already a sufficient indicator from its qualitative median income values.
```{r}
df_feat$`education-num` <- NULL
```

2. Age: 

We decide to break age into 7 bins of ranges, to improve classification: 

- 15- 24 years
- 25- 34 years
- 35 -44 years
- 45 - 54 years
- 55 - 64 years
- 65 -74 years
- 75 years and older

```{r}
age_combine <- function(data){
  data$'age' <- cut(data$age, c(seq(14,74, 10), 90), labels = 1:7)
  data$'age' <- as.factor(data$'age')
  data
}

df_feat <- age_combine(df_feat)
```


3. Race: 

```{r}
plot(table(df_feat$sex,df_feat$race,df_feat$income), las =1, main = "Cross ratio between Gender, Ethicity, and Income")
```

We observed that less females of minorities class earn more than 50K than white female. We decided to make a new column based on gender and minority status. For example, if individual is female and is black, this person will in class "fb"
-------------------------------------

-------------------------------------

We will also combine other with  Amer-Indian-Eskimo and Other together since their population is small. 

```{r}
race_combine = function(dat){
  dat <- data.table(dat)
  dat$race = as.character(dat$race)
  race = unique(dat$race)
  dat[, race := ifelse(race ==" Amer-Indian-Eskimo", " Other", race)] 
  dat$sex = as.character(dat$sex)
  sex = unique(dat$sex)
  gen_race = rep("NA", nrow(dat))
   for (i in 1:nrow(dat)){
     for (r in race){
       if (dat$race[i] == r){
         if (dat$sex[i] == " Female"){
           gen_race[i] = paste0("f", substr(r, 1, 3))
         } else{
           gen_race[i] = paste0("m", substr(r, 1, 3))
         }
       }
       }
   }
   gen_race = gsub(gen_race, pattern = " ", replacement = "")
   dat$gen_race = gen_race
   return (dat)
}
df_feat = race_combine(df_feat)
```


3. Marital_status
For marital status, we split the groups into based on whether or not that person was married, considered to legally have a spouse, and whether or not their spouse was living with them. "Has-Spouse" indicates that the person was married and with their spouse (Married-civ-spouse for civilian spouses, and Married-AF-spouse for spouses from the armed forces), whereas "Married-spouse-absent" and "Separated" denoted an "Absent-Spouse". Divorced and Widowed were placed under the same category as "No-Spouse", while Never-married stayed the same but was renamed "Single". 

```{r}
#Original data
tbl_marital <- table(df$marital_status, df$income) 
tbl_marital

marital_combine <- function(data){
  data <- as.data.frame(data)
  data$marital_status = gsub(
        "^ Divorced","No-Spouse",data$marital_status)
    data$marital_status = gsub(
        "^ Widowed","No-Spouse",data$marital_status)
    data$marital_status = gsub(
        "^ Married-spouse-absent","Absent-Spouse",data$marital_status)
    data$marital_status = gsub(
        "^ Never-married","Single",data$marital_status)
    data$marital_status = gsub(
        "^ Separated","Absent-Spouse",data$marital_status)
    
    data$marital_status = gsub(
        "^ Married-AF-spouse","Has-Spouse",data$marital_status)
    data$marital_status = gsub(
        "^ Married-civ-spouse","Has-Spouse",data$marital_status)
    data
}

df_feat <- marital_combine(df_feat)

#After cleaning:
tbl_marital <- table(df_feat$marital_status, df_feat$income) 
tbl_marital
```

4. marital-status and sex
```{r}
mrg_combine = function(dat){
  dat <- data.table(dat)
   dat$`marital-status` = as.character(dat$`marital-status`)
   mrg = unique(dat$`marital-status`)
   
   dat$sex = as.character(dat$sex)
   sex = unique(dat$sex)
   gen_mrg = rep("NA", nrow(dat))
   for (i in 1:nrow(dat)){
     for (m in mrg){
       if (dat$`marital-status`[i] == m){
         if (dat$sex[i] == " Female"){
           gen_mrg [i] = paste0("f", substr(m, 1, 3))
         } else{
           gen_mrg [i] = paste0("m", substr(m, 1, 3))
         }
       }
       }
   }
   gen_mrg  = gsub(gen_mrg , pattern = " ", replacement = "")
   dat$gen_mrg  = gen_mrg 
   return (dat)
 } ###Need clarification
df_feat = df_feat(df_feat) #Not sure what's going on here - ask My? Mrg_combine it?
```

5. Occupation
Splitting up Occupation was largely based on three levels - white vs blue collar, service vs not service, and then skilled vs. not skilled for not service jobs.
  
```{r} 
occupation_combine <- function(data){
    data <- as.data.frame(data)
    data$occupation =   
          gsub("^ Adm-clerical","White Collar Not Skilled",data$occupation)
    data$occupation =   
          gsub("^ Armed-Forces","Military",data$occupation)
    data$occupation =   
          gsub("^ Craft-repair","Blue-Collar Services",data$occupation)
    data$occupation = 
          gsub("^ Exec-managerial","White-Collar Skilled",data$occupation)
    data$occupation = 
          gsub("^ Farming-fishing","Blue-Collar Skilled",data$occupation)
    data$occupation = 
          gsub("^ Handlers-cleaners","Other Services",data$occupation)
    data$occupation = 
          gsub("^ Machine-op-inspct","Blue-Collar Skilled",data$occupation)
    data$occupation = 
          gsub("^ Other-service","Other Services",data$occupation)
    data$occupation = 
          gsub("^ Priv-house-serv","Other Services",data$occupation)
    data$occupation = 
          gsub("^ Prof-specialty","White-Collar Skilled",data$occupation)
    data$occupation = 
          gsub("^ Protective-serv","White Collar Services",data$occupation)
    data$occupation = 
          gsub("^ Sales","White Collar Services",data$occupation)
    data$occupation =   
          gsub("^ Tech-support","White Collar Services",data$occupation)
    data$occupation = 
          gsub("^ Transport-moving","Blue-Collar Services",data$occupation)
    data
} 

df_feat <- occupation_combine(df_feat)
```

6. Native_country
Splitting up countries was largely based on geographic location (namely segments of Latin America, Europe, and Asia), political relations, and the level of development of the economy (using the HDI index for 1994, as well as examining the list of developed and developing countries). Countries with strong political ties, close geographic location, and similar economies tended to be grouped together. There are at least two groups per continent (of the countries within the data). 

The groupings are: 
  
  * Carribean-1: Columbia, Dominican-Republic, Outlying-US(Guam-USVI-etc)
  * Carribean-2: Jamaica, Puerto Rico, Trinadad&Tobago, Haiti
  * Canada: Canada
  * US: United States, Cuba
  * Central-America: El-Salvador, Guatemala, Honduras, Mexico, Nicaragua
  * Central-Europe: Germany, Greece, Italy, Yugoslavia
  * Central-West: France, Holand-netherlands
  * China: China, Hong
  * East-Europe: Hungary, Poland, South
  * England: England
  * Ireland-Scotland: Ireland, Scotland
  * Japan: Japan
  * South America: Ecuador, Peru
  * South Asia, 1: India, Iran, Cambodia
  * South Asia, 2: Laos, Thailand, Vietnam 
  * South Asia, 3: Philippines, Taiwan
  
```{r}
country_combine <- function(data){
    data <- as.data.frame(data)
      data$native_country = gsub(
          "^ Cambodia","South Asia, 1",data$native_country)
      data$native_country = gsub(
          "^ Canada","Canada",data$native_country)
      data$native_country = gsub(
          "^ China","China",data$native_country)
       data$native_country = gsub(
          "^ Columbia","Carribean-1",
          data$native_country)
      data$native_country = gsub(
          "^ Cuba","US",data$native_country)
      data$native_country = gsub(
          "^ Dominican-Republic","Carribean-1",
          data$native_country)
      data$native_country = gsub(
          "^ Ecuador","South America",data$native_country)
      data$native_country = gsub(
          "^ El-Salvador","Central-America",
          data$native_country)
      data$native_country = gsub(
          "^ England","England",data$native_country)
      data$native_country = gsub(
          "^ France","Central-West",data$native_country)
      data$native_country = gsub(
          "^ Germany","Central-Europe",data$native_country)
      data$native_country = gsub(
          "^ Greece","Central-Europe",data$native_country)
      data$native_country = gsub(
          "^ Guatemala","Central-America",
          data$native_country)
      data$native_country = gsub(
          "^ Haiti","Carribean-2",data$native_country)
      data$native_country = gsub(
          "^ Holand-Netherlands","Central-West",
          data$native_country)
      data$native_country = gsub(
          "^ Honduras","Central-America",
          data$native_country)
      data$native_country = gsub(
          "^ Hong","China",data$native_country)
      data$native_country = gsub(
          "^ Hungary","East-Europe",data$native_country)
      data$native_country = gsub(
          "^ India","South Asia, 1",data$native_country)
      data$native_country = gsub(
          "^ Iran","South Asia, 1",data$native_country)
      data$native_country = gsub(
          "^ Ireland","Ireland-Scotland",
          data$native_country)
      data$native_country = gsub(
          "^ Italy","Central-Europe",data$native_country)
      data$native_country = gsub(
          "^ Jamaica","Carribean-2",data$native_country)
      data$native_country = gsub(
          "^ Japan","Japan",data$native_country)
      data$native_country = gsub(
          "^ Laos","South Asia, 2",data$native_country)
      data$native_country = gsub(
          "^ Mexico","Central-America",
          data$native_country)
      data$native_country = gsub(
          "^ Nicaragua","Central-America",
          data$native_country)
      data$native_country = gsub(
          "^ Peru","South America",data$native_country)
      data$native_country = gsub(
          "^ Philippines","South Asia, 3",
          data$native_country)
      data$native_country = gsub(
          "^ Poland","East-Europe",data$native_country)
      data$native_country = gsub(
          "^ Portugal","West-Europe",data$native_country)
      data$native_country = gsub(
          "^ Puerto-Rico","Carribean-2",
          data$native_country)
      data$native_country = gsub(
          "^ Scotland","Ireland-Scotland",
          data$native_country)
      data$native_country = gsub(
          "^ South","East-Europe",data$native_country)
      data$native_country = gsub(
          "^ Taiwan","South Asia, 3",data$native_country)
      data$native_country = gsub(
          "^ Thailand","South Asia, 2",data$native_country)
      data$native_country = gsub(
          "^ Trinadad&Tobago","Carribean-2",
          data$native_country)
      data$native_country = gsub(
          "^ United-States","US",data$native_country)
      data$native_country = gsub(
          "^ Vietnam","South Asia, 2",data$native_country)
      data$native_country = gsub(
          "^ Yugoslavia","Central-Europe",data$native_country)
      #Having some issues with this one:
      vecc <- which(data$native_country == 
                      " Outlying-US(Guam-USVI-etc)")
      data$native_country[vecc] <- "Carribean-1"
      data
}
      
df_feat <- country_combine(df_feat)
tbl_country <- table(df_feat$native_country, df_feat$income) 
tbl_country
```

7. Workclass
The workclass variable currently has 8 different levels - Federal-gov, Local-goc, State-gov, Private, Self-emp-inc, Self-emp-not-inc, Without pay, and Never-worked. We decided to group all the government jobs together, after examining the income ratio for each. We did not combine the self employed classes together, given that self employed incorporated positions tend to have higher pay than not-incorporated ones. Finally, We combined those that never worked with those that were without pay into a new group, of those who were not working. 

```{r}
workclass_combine <- function(data){
    data <- as.data.frame(data)
  data$workclass = gsub(
        "^ Federal-gov","Gov",data$workclass)
    data$workclass = gsub(
        "^ Local-gov","Gov",data$workclass)
    data$workclass = gsub(
        "^ State-gov","Gov",data$workclass)
    data$workclass = gsub(
        "^ Private","Private",data$workclass)
    data$workclass = gsub(
        "^ Self-emp-inc","Self-Employed-Incorp",data$workclass)
    data$workclass = gsub(
        "^ Self-emp-not-inc","Self-Employed-Not-Incorp",data$workclass)
    data$workclass = gsub(
        "^ Without-pay","Not-Working",data$workclass)
    data$workclass = gsub(
        "^ Never-worked","Not-Working",data$workclass)
    data
}

df_feat <- workclass_combine(df_feat)
tbl_work <- table(df_feat$workclass, df_feat$income) 
tbl_work
```



8. Relationships
For relationships, this is the relationship of the surveyor to a central household figure. Unmarried referred to an unmarried partner; as such, we combined that we "Not-in-family" to make a grouping of Not-relative relationships. Husband and Wife were grouped together under "Spouse", while the last two remaining classes were combined as "Other-relative" relationships.

```{r}
relation_combine <- function(data){
    data <- as.data.frame(data)
  data$relationship = gsub(
        "^ Husband","Spouse",data$relationship)
    data$relationship = gsub(
        "^ Wife","Spouse",data$relationship)
    data$relationship = gsub(
        "^ Other-relative","Other-relative",data$relationship)
    data$relationship = gsub(
        "^ Own-child","Other-relative",data$relationship)
    data$relationship = gsub(
        "^ Unmarried","Not-relative",data$relationship)
    data$relationship = gsub(
        "^ Not-in-family","Not-relative",data$relationship)
    data
}

df_feat <- relation_combine(df_feat)

tbl_relat <- table(df_feat$relationship, df_feat$income)
tbl_relat
```

9. Capital_gain
We noticed that there appear to be outliers for capital gain (there was a chunk of data that had values of over 99999). As such, we decided to change these outlier values to the mean value of the capital gains.
```{r}
cap_gain_clean_outlier <- function(data){
    data <- as.data.frame(data)
  mean_cg <- mean(data$'capital-gain')
  data$`capital-gain`[which(data$`capital-gain` == 99999)] <- mean_cg
  data
} 

df_feat <- cap_gain_clean_outlier(df_feat)
```

10. Capital Loss
We didn't do anything for capital loss, as the outliers did not give us the same amount of concern as we saw in the capital gain variable. We left capital loss as a continuous variable.

11. Hours
For the hours-per-week worked, we decided to bin the data together based off of their quartiles. We examined where the cut-offs of each percentile (of 10%) was. Based off of those unique cut-off points, we generated 6 levels to bin our data to hours of:

- [1,24]
- (24,35]
- (35,40]
- (40,48]
- (48,55]
- (55,99]

```{r}
quant <- quantile(df$`hours-per-week`,seq(0,1,.10))

hours_combine <- function(data){
    data <- as.data.frame(data)
  data$`hours-per-week` <-
  cut(data$`hours-per-week`,
      unique(quant),include.lowest=TRUE)
  data
}

df_feat <- hours_combine(df_feat)
```

12. Income
For income (1 if over 50K, 0 if less)
```{r}
Income_factor <- function(data){
    data <- as.data.frame(data)
  data$income = gsub(
    "^ <=50K","Less.than.50k",data$income)
  data$income = gsub(
    "^ >50K","More.than.50k",data$income)
  data
}

df_feat <- Income_factor(df_feat)
```

As one more precaution, we confirm that everything that we just changed that should be a factor is a factor. 
```{r}
factorize <- function(data){
    data <- as.data.frame(data)
    cols <- c("age", "workclass", 'education', 'marital_status', 'occupation', 'relationship', 'race', 'sex', 'native_country', 'income') #no finl-weight because that is continuous
    data[cols] <- lapply(data[cols], as.factor)
    data
}

df_feat <- factorize(df_feat)
```

Finally, we run all the functions we had before on our imputed data set and our NA data set, and export our datasets (our OG dataset with NA values instead of '?', and then feature selected on our OG data,removed NA set, and imputed set) to csv files.

```{r}
#This is all done in the "Functions for test" file. Also, need to cross-check functions in this doc with that one
```

//
## Data Transformation
```{r}
### Let's check the box plot: 
boxplot(df_cont)
### check the distribution plot 

ggpairs(df_cont)
### V1 and V3 and right-skewed distribution
### V11 and V12 hav heavy tail distribution 
## 
```

We observed:

 * V1 and V3 can achieve normality by performing log transformation.
 * V13 may need more work than regular log transformation. We can try power transformation family. 
 * V11 and V12 have heavy tails, which requires more research. One suggestion is to use inverse hyperbolic sine transformation which takes care of zero. 
 

Let's try to transform the distribution: 

```{r}
df_transform = cbind(df)

par(mfrow= c(1,2))
## try log transform for V1
v1_trans = log(df_transform$age)
plot(density(v1_trans),main= "PDF")
### qqplot with normality test
qqPlot(v1_trans, dist= "norm", col=palette()[1],xlab = paste0("Ad-test p-value: ", ad.test(v1_trans)$p.value), pch = 19)

v3_trans = log(df_transform$fnlwgt)
plot(density(v3_trans),main= "PDF")
qqPlot(v3_trans, dist= "norm", col=palette()[1],xlab = paste0("Ad-test p-value: ", ad.test(v3_trans)$p.value), pch = 19)

lam_13 = BoxCox.lambda(df_transform$hours-per-week)
lam_13
v13_trans = BoxCox(df$V13, lam_13)
plot(density(v13_trans),main= "PDF")
qqPlot(v13_trans, dist= "norm", col=palette()[1], pch = 19, main = "With Box Cox transformation")
#### Doesn't work for v13

v13_trans = tan(df_transform$hours-per-week)
plot(density(v13_trans),main= "PDF")
qqPlot(v13_trans, dist= "norm", col=palette()[1], pch = 19, main = "With tan transformation")
#### Looks like this is reasonable transformation but let's check other transformation

power = seq(1.5, 3, 0.5)
for (p in power){
  trans = (df_transform$V13)**p
  plot(density(trans),main= "PDF")
  qqPlot(trans, dist= "norm", col=palette()[1], pch = 19, main = paste("With Power",p, "transformation"))
}


ihs = function(x){
  y = log(x + sqrt(x^2+1))
  return (y)
}

v11_trans = ihs(df_transform$capital_gain)
plot(density(v11_trans),main= "PDF")
qqPlot(v11_trans, dist= "norm", main = "With Inverse Hyperbolic Sine Transformation",col=palette()[1], pch = 19)


v12_trans = ihs(df_transform$capital_loss)
plot(density(v12_trans), main= "PDF")
qqPlot(v12_trans, dist= "norm", col=palette()[1], main = "With Inverse Hyperbolic Sine Transformation", pch = 19)
```


Thus we will do the following transformation: 
 
 * Log transformation : age, fnlwgt

```{r}
variable_transform = function(dat){
  dat$age = log(dat$age)
  dat$fnlwgt = log(dat$fnlwgt)
}
```

Feel free to include output/ and images/ folders in your file structure to store results from the EDA stage (and avoiding polluting the report).


#Analysis and Methods (model building)

For each of the performed methods, you can include a brief description of what each method does (e.g. basic working principles, key ideas, goal), the functions and packages used to carry out the model building process, the main results (tables, summaries, graphs) and their corresponding descriptions and interpretations.



# Conclusion(s)/Discussion

The conclusion should reprise the prediction task of the introduction,
perhaps augmented by some additional observations or details gleaned from the analysis/methods section. New questions, future work, etc., can also be raised here.